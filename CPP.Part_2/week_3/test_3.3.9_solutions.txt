[ ] При поиске в unordered_set всегда просматривается O(1) элементов контейнера.
[ ] Если некоторый тип можно хранить в set, то он же может быть ключом в unordered_map.
[X] Если некоторый тип можно хранить в set, то он же может быть ключом в map.
[ ] Элементы в unordered_set хранятся не в порядке возрастания, а в порядке добавления.
[ ] В set можно хранить только такие типы, для которых определён оператор <.
[X] При поиске в set всегда просматривается O(log n) элементов контейнера.

1)  При поиске в unordered_set всегда просматривается O(1) элементов контейнера.

Хеш-функция может выдавать индекс, по которому уже будет что-то храниться в таблице. Это называется коллизиями. Если коллизий много, то алгоритму поиска придется перебирать более одного элемента в поисках совпадений.

2)  Если некоторый тип можно хранить в set, то он же может быть ключом в unordered_map.

unordered_map - это хеш-таблица, а хранение в ней связано только с работой хеш-функции от значений ключа. Связи не видно.

3)  Если некоторый тип можно хранить в set, то он же может быть ключом в map.

map - это такой set, у которого есть еще кармашек для значения. Ключом в set является само значение, для которого требуется наличие отношения порядка (operator<).

4)  Элементы в unordered_set хранятся не в порядке возрастания, а в порядке добавления.

unordered_set  - это хеш-таблица, у которой порядок определяется индексом, рассчитываемым хеш-функцией.

5)  В set можно хранить только такие типы, для которых определён оператор <.

А как иначе?

﻿6)  При поиске в set всегда просматривается O(log n) элементов контейнера. 

set - это дерево поиска. В худшем случае пройдем высоту дерева. Если дерево сбалансировано (каким является set), то высотой дерева станет log(n), где n - число элементов.
 
Александр Смаль:
> 5) В set можно хранить только такие типы, для которых определён оператор <. 
Можно определить собственный компаратор, но не определять оператор <
https://stepik.org/lesson/53377/step/6﻿

Никита Субботин:
> 2)   Если некоторый тип можно хранить в set, то он же может быть ключом в unordered_map.

Даже не вникая в суть хранения данных в хэш-таблице, можно увидеть, что на cppreference для хэш-таблиц определены другие требования к тем операторам / методам, которые должны быть определены для класса ключа. Конкретно, для хэш-таблиц -- это метод получения хэша и метод проверки на равенство. Для упорядоченных списков -- это метод строгого сравнения

> 5) А еще можно использовать std::greater в качестве второго параметра шаблона. Например


std::set<int, std::greater<int>> s = { 1, 3, 2, 5, 4 };

for (auto & a : s) { std::cout << a << '\t'; }  // Вывод: 5 4 3 2 1

@Александр_Смаль,
В чем причины того, что вы используете формулировку "всегда просматривается" вместо "в худшем случае просматривается"? Потому что при попытке получения элемента в корне дерева просматривается всего один элемент, следовательно, O(log n) просматривается не всегда
 
Александр Смаль:
@Никита_Субботин, O(log n)  - это по определению оценка сверху. Т.е., например, log log n - это O(log n).
